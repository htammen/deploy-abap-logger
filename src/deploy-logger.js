const { execSync, spawn } = require('child_process');
const { formatDate, formatTime } = require('./formatDate');
const fs = require('fs-extra');

/**
 * Check for unstaged changes in the working tree
 */
const hasUnstagedChanges = () => {
    return new Promise((resolve, reject) => {
        const result = {};
        const child = spawn('git', ['diff-files', '--cc'])
        child.on('exit', (code) => {
            //console.log("git diff-files exited with: " + code);
            result.code = code;
            resolve(result);
        })
        child.stdout.on('data', (data) => {
            // there is always an empty line at the end
            result.hasChanges = data.toString().split("\n").length > 1;
            //console.log(`stdout: ${data}`)
        })
        child.stderr.on('data', (data) => {
            console.error(`stderr: ${data}`);
            reject(data.toString());
        });
    })
}

/**
 * Check for uncommited changes in the index
 */
const hasUncommitedChanges = () => {
    return new Promise((resolve, reject) => {
        const result = {};
        const child = spawn('git', ['diff-index', '--cached', 'HEAD']);
        child.on('exit', (code) => {
            //console.log("git diff-files exited with: " + code);
            result.code = code;
            resolve(result);
        })
        child.stdout.on('data', (data) => {
            // there is always an empty line at the end
            result.hasChanges = data.toString().split("\n").length > 1;
            //console.log(`stdout: ${data}`)
        })
        child.stderr.on('data', (data) => {
            console.error(`stderr: ${data}`);
            reject(data.toString());
        });
    })
}

// /**
//  * Tag the commit with the current timestamp
//  */
// const gitTagWithTimeStamp = () => {
//     return new Promise((resolve, reject) => {
//         const sTag = formatDate(new Date());
//         const sMsg = `-m "tag ${sTag} generated by tools-gittag"`;
//         const child = spawn('git', ['tag', sTag, '-a', sMsg])
//         child.on('exit', (code) => {
//             //console.log("git diff-files exited with: " + code);
//             resolve(code);
//         })
//         child.stdout.on('data', (data) => {
//             console.log(``);
//         })
//         child.stderr.on('data', (data) => {
//             console.error(`stderr: ${data}`);
//             reject(data.toString());
//         });
//     })
// }

const getGitBranch = async () => {
    return new Promise((resolve, reject) => {
        let result = '';
        const child = spawn('git', ['branch', '--show-current']);
        child.on('exit', (code) => {
            // console.log("git branch exited with: " + code);
            // console.log(`result: ${result}`)
            resolve(result);
        })
        child.stdout.on('data', (data) => {
            // console.log(`stdout: ${data}`)
            result = data.toString().replace('\n', '');
        })
        child.stderr.on('data', (data) => {
            console.error(`stderr: ${data}`);
            reject(data.toString());
        });
    })
}

const getGitUser = async () => {
    return new Promise((resolve, reject) => {
        let result = '';
        const child = spawn('git', ['config', 'user.name']);
        child.on('exit', (code) => {
            // console.log("git config user.name exited with: " + code);
            // console.log(`result: ${result}`)
            resolve(result);
        })
        child.stdout.on('data', (data) => {
            // console.log(`stdout: ${data}`)
            result = data.toString().replace('\n', '');
        })
        child.stderr.on('data', (data) => {
            console.error(`stderr: ${data}`);
            reject(data.toString());
        });
    })
}

/*
 * get information about current commit 
 * returns {commit: string, info: string}
*/
const getGitCommitInfo = async () => {
    try {
    const hasUnstaged = await hasUnstagedChanges()
    if (hasUnstaged.hasChanges) {
        return { commit: '', info: 'deployed with unstaged changes' }
    }
    const hasUncommited = await hasUncommitedChanges();
    if (hasUncommited.hasChanges) {
        return { commit: '', info: 'deployed with uncommited changes' }
    }
    return new Promise((resolve, reject) => {
        let result = '';
        const child = spawn('git', ['log', '--pretty=oneline']);
        child.on('exit', (code) => {
            resolve({ commit: result, info: '' });
        })
        child.stdout.on('data', (data) => {
            const lData = data.toString().replace('\n', '');
            const commitHash = lData.split(' ')[0];
            result = commitHash;
        })
        child.stderr.on('data', (data) => {
            console.error(`stderr: ${data}`);
            reject(data.toString());
        });
    })
    } catch(ex) {
        console.log(`there seems to be no git commit in this repo.\n${ex}`)
        return {commit: '', info: 'something went wrong when checking unstaged changes in git repo'}
    }
}


const getGitParams = async () => {
    const result = {}
    result.branch = await getGitBranch()
    result.username = await getGitUser()
    return result
}

/**
 * gets the package name and version from package.json file 
 * returns {name: string, version: string}
 */
const getPackageInfo = async () => {
    const packageJson = await fs.readJson('package.json')
    return { name: packageJson.name, version: packageJson.version }
}

const main = async () => {
    let exitCode = 1;
    try {
        const logFile = 'deploy-log.json';
        const gitParams = await getGitParams();
        const pkgJson = await getPackageInfo();
        const commitInfo = await getGitCommitInfo();
        const result = {
            project: pkgJson.name,
            version: pkgJson.version,
            branch: gitParams.branch,
            username: gitParams.username,
            date: formatDate(new Date()),
            time: formatTime(new Date()),
            commit: commitInfo.commit,
            info: commitInfo.info
        }
        await fs.ensureFile(logFile)
        const json = await fs.readJson(logFile, { throws: false }) || []
        const endResult = [result].concat(json);
        await fs.writeJson(logFile, endResult)
        console.log('log entry written to file')
    } catch (ex) {
        console.log(`exception raised: ${ex}`)
    }
    process.exit(exitCode);
}

//main();

module.exports = main
